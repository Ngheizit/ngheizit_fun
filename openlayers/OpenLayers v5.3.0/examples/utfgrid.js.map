{"version":3,"sources":["webpack:///../src/ol/source/UTFGrid.js","webpack:///./utfgrid.js"],"names":["UTFGrid_CustomTile","Tile","CustomTile","tileCoord","state","src","extent","preemptive","jsonp","super","this","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","getImage","getData","coordinate","const","xRelative","yRelative","row","Math","floor","length","let","code","charCodeAt","data","id","forDataAtCoordinate","callback","opt_this","opt_request","TileState","IDLE","Object","events","EventType","CHANGE","e","call","loadInternal_","setTimeout","bind","getKey","handleError_","ERROR","changed","handleLoad_","json","EMPTY","LOADING","net","client","XMLHttpRequest","addEventListener","onXHRLoad_","onXHRError_","open","send","event","status","response","JSON","parse","responseText","err","load","ol_Tile","source_UTFGrid","TileSource","UTFGrid","options","projection","proj","State","undefined","tileUrlFunction_","tileurlfunction","template_","url","handleTileJSONResponse","handleTileJSONError","tileJSON","asserts","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","getTileCoordForCoordAndResolution","getTile","getProjection","setState","epsg4326Projection","sourceProjection","transform","ol_extent","minZoom","maxZoom","tilegrid","grids","attributionExtent","getExtent","setAttributions","frameState","READY","z","x","y","pixelRatio","tileCoordKey","tilecoord","tileCache","containsKey","get","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tile","getTileCoordExtent","set","useTile","source_Tile","key","mapLayer","layer_Tile","source","TileJSON","gridSource","gridLayer","view","View","center","zoom","mapElement","document","getElementById","map","Map","layers","target","infoElement","flagElement","nameElement","infoOverlay","Overlay","element","offset","stopEvent","addOverlay","displayCountryInfo","viewResolution","getResolution","style","cursor","innerHTML","setPosition","on","evt","dragging","getEventCoordinate","originalEvent"],"mappings":"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","file":"utfgrid.js","sourcesContent":["/**\n * @module ol/source/UTFGrid\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport {assert} from '../asserts.js';\nimport {listenOnce} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {jsonp as requestJSONP} from '../net.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport SourceState from './State.js';\nimport TileSource from './Tile.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\n\nexport class CustomTile extends Tile {\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {TileState} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative = (coordinate[0] - this.extent_[0]) /\n        (this.extent_[2] - this.extent_[0]);\n    const yRelative = (coordinate[1] - this.extent_[1]) /\n        (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(this: T, *)} callback Callback.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @param {boolean=} opt_request If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @template T\n   */\n  forDataAtCoordinate(coordinate, callback, opt_this, opt_request) {\n    if (this.state == TileState.IDLE && opt_request === true) {\n      listenOnce(this, EventType.CHANGE, function(e) {\n        callback.call(opt_this, this.getData(coordinate));\n      }, this);\n      this.loadInternal_();\n    } else {\n      if (opt_request === true) {\n        setTimeout(function() {\n          callback.call(opt_this, this.getData(coordinate));\n        }.bind(this), 0);\n      } else {\n        callback.call(opt_this, this.getData(coordinate));\n      }\n    }\n  }\n\n\n  /**\n   * @inheritDoc\n   */\n  getKey() {\n    return this.src_;\n  }\n\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.EMPTY;\n    this.changed();\n  }\n\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(this.src_, this.handleLoad_.bind(this),\n          this.handleError_.bind(this));\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */(JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n\n  /**\n   * @override\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    }\n  }\n}\n\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false`, you need to pass `true` as `opt_request`\n * to the `forDataAtCoordinateAndResolution` method otherwise no data\n * will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n */\n\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: SourceState.LOADING\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = options.preemptive !== undefined ?\n      options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(options.url, this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this));\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n\n  }\n\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */(JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*)} callback Callback.\n   * @param {boolean=} opt_request If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(\n    coordinate, resolution, callback, opt_request) {\n    if (this.tileGrid) {\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(\n        coordinate, resolution);\n      const tile = /** @type {!CustomTile} */(this.getTile(\n        tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection()));\n      tile.forDataAtCoordinate(coordinate, callback, null, opt_request);\n    } else {\n      if (opt_request === true) {\n        setTimeout(function() {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState(SourceState.ERROR);\n  }\n\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection, sourceProjection);\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: extentFromProjection(sourceProjection),\n      maxZoom: maxZoom,\n      minZoom: minZoom\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState(SourceState.ERROR);\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution'] !== undefined) {\n      const attributionExtent = extent !== undefined ?\n        extent : epsg4326Projection.getExtent();\n\n      this.setAttributions(function(frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState(SourceState.READY);\n\n  }\n\n\n  /**\n   * @inheritDoc\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return (\n        /** @type {!import(\"../Tile.js\").default} */ (this.tileCache.get(tileCoordKey))\n      );\n    } else {\n      const tileCoord = [z, x, y];\n      const urlTileCoord =\n          this.getTileCoordForTileUrlFunction(tileCoord, projection);\n      const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n      const tile = new CustomTile(\n        tileCoord,\n        tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n        tileUrl !== undefined ? tileUrl : '',\n        this.tileGrid.getTileCoordExtent(tileCoord),\n        this.preemptive_,\n        this.jsonp_);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  }\n\n\n  /**\n   * @inheritDoc\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\n\nexport default UTFGrid;\n","import Map from '../src/ol/Map.js';\nimport Overlay from '../src/ol/Overlay.js';\nimport View from '../src/ol/View.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport TileJSON from '../src/ol/source/TileJSON.js';\nimport UTFGrid from '../src/ol/source/UTFGrid.js';\n\nconst key = 'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiRk1kMWZaSSJ9.E5BkluenyWQMsBLsuByrmg';\n\nconst mapLayer = new TileLayer({\n  source: new TileJSON({\n    url: 'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' + key\n  })\n});\n\n\nconst gridSource = new UTFGrid({\n  url: 'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' + key\n});\n\nconst gridLayer = new TileLayer({source: gridSource});\n\nconst view = new View({\n  center: [0, 0],\n  zoom: 1\n});\n\nconst mapElement = document.getElementById('map');\nconst map = new Map({\n  layers: [mapLayer, gridLayer],\n  target: mapElement,\n  view: view\n});\n\nconst infoElement = document.getElementById('country-info');\nconst flagElement = document.getElementById('country-flag');\nconst nameElement = document.getElementById('country-name');\n\nconst infoOverlay = new Overlay({\n  element: infoElement,\n  offset: [15, 15],\n  stopEvent: false\n});\nmap.addOverlay(infoOverlay);\n\nconst displayCountryInfo = function(coordinate) {\n  const viewResolution = /** @type {number} */ (view.getResolution());\n  gridSource.forDataAtCoordinateAndResolution(coordinate, viewResolution,\n    function(data) {\n      // If you want to use the template from the TileJSON,\n      //  load the mustache.js library separately and call\n      //  info.innerHTML = Mustache.render(gridSource.getTemplate(), data);\n      mapElement.style.cursor = data ? 'pointer' : '';\n      if (data) {\n        flagElement.src = 'data:image/png;base64,' + data['flag_png'];\n        nameElement.innerHTML = data['admin'];\n      }\n      infoOverlay.setPosition(data ? coordinate : undefined);\n    });\n};\n\nmap.on('pointermove', function(evt) {\n  if (evt.dragging) {\n    return;\n  }\n  const coordinate = map.getEventCoordinate(evt.originalEvent);\n  displayCountryInfo(coordinate);\n});\n\nmap.on('click', function(evt) {\n  displayCountryInfo(evt.coordinate);\n});\n"],"sourceRoot":""}