{"version":3,"sources":["webpack:///../src/ol/control/ZoomSlider.js","webpack:///./zoomslider.js"],"names":["Direction","render","mapEvent","frameState","this","sliderInitialized_","initSlider_","const","res","viewState","resolution","currentResolution_","setThumbPosition_","control_ZoomSlider","Control","ZoomSlider","opt_options","options","super","element","document","createElement","dragListenerKeys_","undefined","direction_","dragging_","heightLimit_","widthLimit_","previousX_","previousY_","thumbSize_","duration_","duration","className","thumbElement","setAttribute","css","containerElement","appendChild","dragger_","PointerEventHandler","Object","events","pointer_EventType","POINTERDOWN","handleDraggerStart_","POINTERMOVE","handleDraggerDrag_","POINTERUP","handleDraggerEnd_","EventType","CLICK","handleContainerClick_","Event","disposeInternal","dispose","call","setMap","map","container","containerSize","offsetWidth","offsetHeight","thumb","computedStyle","getComputedStyle","thumbWidth","parseFloat","thumbHeight","event","view","getMap","getView","relativePosition","getRelativePosition_","offsetX","offsetY","getResolutionForPosition_","animate","constrainResolution","easing","originalEvent","target","firstElementChild","setHint","ViewHint","INTERACTING","clientX","clientY","length","drag","end","push","MOUSEMOVE","MOUSEUP","deltaX","style","left","deltaY","top","setResolution","forEach","position","getPositionForResolution_","x","y","let","amount","math","getResolutionForValueFunction","fn","getValueForResolutionFunction","control_Control","createMap","divId","source","OSM","layer","Tile","Map","layers","View","center","zoom","zoomslider","addControl"],"mappings":"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","file":"zoomslider.js","sourcesContent":["/**\n * @module ol/control/ZoomSlider\n */\nimport ViewHint from '../ViewHint.js';\nimport Control from './Control.js';\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\nimport {easeOut} from '../easing.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {stopPropagation} from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {clamp} from '../math.js';\nimport PointerEventType from '../pointer/EventType.js';\nimport PointerEventHandler from '../pointer/PointerEventHandler.js';\n\n\n/**\n * The enum for available directions.\n *\n * @enum {number}\n */\nconst Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoomslider'] CSS class name.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n */\n\n\n/**\n * @classdesc\n * A slider type of control for zooming.\n *\n * Example:\n *\n *     map.addControl(new ZoomSlider());\n *\n * @api\n */\nclass ZoomSlider extends Control {\n\n  /**\n   * @param {Options=} opt_options Zoom slider options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options ? opt_options : {};\n\n    super({\n      element: document.createElement('div'),\n      render: options.render || render\n    });\n\n    /**\n      * @type {!Array.<import(\"../events.js\").EventsKey>}\n      * @private\n      */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * Will hold the current resolution of the view.\n     *\n     * @type {number|undefined}\n     * @private\n     */\n    this.currentResolution_ = undefined;\n\n    /**\n     * The direction of the slider. Will be determined from actual display of the\n     * container and defaults to Direction.VERTICAL.\n     *\n     * @type {Direction}\n     * @private\n     */\n    this.direction_ = Direction.VERTICAL;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.heightLimit_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.widthLimit_ = 0;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.previousX_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.previousY_;\n\n    /**\n     * The calculated thumb size (border box plus margins).  Set when initSlider_\n     * is called.\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.thumbSize_ = null;\n\n    /**\n     * Whether the slider is initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.sliderInitialized_ = false;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    const className = options.className !== undefined ? options.className : 'ol-zoomslider';\n    const thumbElement = document.createElement('button');\n    thumbElement.setAttribute('type', 'button');\n    thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;\n    const containerElement = this.element;\n    containerElement.className = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n    /**\n     * @type {PointerEventHandler}\n     * @private\n     */\n    this.dragger_ = new PointerEventHandler(containerElement);\n\n    listen(this.dragger_, PointerEventType.POINTERDOWN,\n      this.handleDraggerStart_, this);\n    listen(this.dragger_, PointerEventType.POINTERMOVE,\n      this.handleDraggerDrag_, this);\n    listen(this.dragger_, PointerEventType.POINTERUP,\n      this.handleDraggerEnd_, this);\n\n    listen(containerElement, EventType.CLICK, this.handleContainerClick_, this);\n    listen(thumbElement, EventType.CLICK, stopPropagation);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    this.dragger_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      map.render();\n    }\n  }\n\n  /**\n   * Initializes the slider element. This will determine and set this controls\n   * direction_ and also constrain the dragging of the thumb to always be within\n   * the bounds of the container.\n   *\n   * @private\n   */\n  initSlider_() {\n    const container = this.element;\n    const containerSize = {\n      width: container.offsetWidth, height: container.offsetHeight\n    };\n\n    const thumb = /** @type {HTMLElement} */ (container.firstElementChild);\n    const computedStyle = getComputedStyle(thumb);\n    const thumbWidth = thumb.offsetWidth +\n        parseFloat(computedStyle['marginRight']) +\n        parseFloat(computedStyle['marginLeft']);\n    const thumbHeight = thumb.offsetHeight +\n        parseFloat(computedStyle['marginTop']) +\n        parseFloat(computedStyle['marginBottom']);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n\n    if (containerSize.width > containerSize.height) {\n      this.direction_ = Direction.HORIZONTAL;\n      this.widthLimit_ = containerSize.width - thumbWidth;\n    } else {\n      this.direction_ = Direction.VERTICAL;\n      this.heightLimit_ = containerSize.height - thumbHeight;\n    }\n    this.sliderInitialized_ = true;\n  }\n\n  /**\n   * @param {MouseEvent} event The browser event to handle.\n   * @private\n   */\n  handleContainerClick_(event) {\n    const view = this.getMap().getView();\n\n    const relativePosition = this.getRelativePosition_(\n      event.offsetX - this.thumbSize_[0] / 2,\n      event.offsetY - this.thumbSize_[1] / 2);\n\n    const resolution = this.getResolutionForPosition_(relativePosition);\n\n    view.animate({\n      resolution: view.constrainResolution(resolution),\n      duration: this.duration_,\n      easing: easeOut\n    });\n  }\n\n  /**\n   * Handle dragger start events.\n   * @param {import(\"../pointer/PointerEvent.js\").default} event The drag event.\n   * @private\n   */\n  handleDraggerStart_(event) {\n    if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {\n      this.getMap().getView().setHint(ViewHint.INTERACTING, 1);\n      this.previousX_ = event.clientX;\n      this.previousY_ = event.clientY;\n      this.dragging_ = true;\n\n      if (this.dragListenerKeys_.length === 0) {\n        const drag = this.handleDraggerDrag_;\n        const end = this.handleDraggerEnd_;\n        this.dragListenerKeys_.push(\n          listen(document, EventType.MOUSEMOVE, drag, this),\n          listen(document, PointerEventType.POINTERMOVE, drag, this),\n          listen(document, EventType.MOUSEUP, end, this),\n          listen(document, PointerEventType.POINTERUP, end, this)\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle dragger drag events.\n   *\n   * @param {import(\"../pointer/PointerEvent.js\").default} event The drag event.\n   * @private\n   */\n  handleDraggerDrag_(event) {\n    if (this.dragging_) {\n      const element = /** @type {HTMLElement} */ (this.element.firstElementChild);\n      const deltaX = event.clientX - this.previousX_ + parseFloat(element.style.left);\n      const deltaY = event.clientY - this.previousY_ + parseFloat(element.style.top);\n      const relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n      this.setThumbPosition_(this.currentResolution_);\n      this.previousX_ = event.clientX;\n      this.previousY_ = event.clientY;\n    }\n  }\n\n  /**\n   * Handle dragger end events.\n   * @param {import(\"../pointer/PointerEvent.js\").default} event The drag event.\n   * @private\n   */\n  handleDraggerEnd_(event) {\n    if (this.dragging_) {\n      const view = this.getMap().getView();\n      view.setHint(ViewHint.INTERACTING, -1);\n\n      view.animate({\n        resolution: view.constrainResolution(this.currentResolution_),\n        duration: this.duration_,\n        easing: easeOut\n      });\n\n      this.dragging_ = false;\n      this.previousX_ = undefined;\n      this.previousY_ = undefined;\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n    }\n  }\n\n  /**\n   * Positions the thumb inside its container according to the given resolution.\n   *\n   * @param {number} res The res.\n   * @private\n   */\n  setThumbPosition_(res) {\n    const position = this.getPositionForResolution_(res);\n    const thumb = /** @type {HTMLElement} */ (this.element.firstElementChild);\n\n    if (this.direction_ == Direction.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position + 'px';\n    } else {\n      thumb.style.top = this.heightLimit_ * position + 'px';\n    }\n  }\n\n  /**\n   * Calculates the relative position of the thumb given x and y offsets.  The\n   * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n   * in pixel units within the dragger limits.\n   *\n   * @param {number} x Pixel position relative to the left of the slider.\n   * @param {number} y Pixel position relative to the top of the slider.\n   * @return {number} The relative position of the thumb.\n   * @private\n   */\n  getRelativePosition_(x, y) {\n    let amount;\n    if (this.direction_ === Direction.HORIZONTAL) {\n      amount = x / this.widthLimit_;\n    } else {\n      amount = y / this.heightLimit_;\n    }\n    return clamp(amount, 0, 1);\n  }\n\n  /**\n   * Calculates the corresponding resolution of the thumb given its relative\n   * position (where 0 is the minimum and 1 is the maximum).\n   *\n   * @param {number} position The relative position of the thumb.\n   * @return {number} The corresponding resolution.\n   * @private\n   */\n  getResolutionForPosition_(position) {\n    const fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position);\n  }\n\n  /**\n   * Determines the relative position of the slider for the given resolution.  A\n   * relative position of 0 corresponds to the minimum view resolution.  A\n   * relative position of 1 corresponds to the maximum view resolution.\n   *\n   * @param {number} res The resolution.\n   * @return {number} The relative position value (between 0 and 1).\n   * @private\n   */\n  getPositionForResolution_(res) {\n    const fn = this.getMap().getView().getValueForResolutionFunction();\n    return 1 - fn(res);\n  }\n}\n\n\n/**\n * Update the zoomslider element.\n * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n * @this {ZoomSlider}\n * @api\n */\nexport function render(mapEvent) {\n  if (!mapEvent.frameState) {\n    return;\n  }\n  if (!this.sliderInitialized_) {\n    this.initSlider_();\n  }\n  const res = mapEvent.frameState.viewState.resolution;\n  if (res !== this.currentResolution_) {\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  }\n}\n\n\nexport default ZoomSlider;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {ZoomSlider} from '../src/ol/control.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport OSM from '../src/ol/source/OSM.js';\n\n\n/**\n * Helper method for map-creation.\n *\n * @param {string} divId The id of the div for the map.\n * @return {module:ol/PluggableMap} The map instance.\n */\nfunction createMap(divId) {\n  const source = new OSM();\n  const layer = new TileLayer({\n    source: source\n  });\n  const map = new Map({\n    layers: [layer],\n    target: divId,\n    view: new View({\n      center: [0, 0],\n      zoom: 2\n    })\n  });\n  const zoomslider = new ZoomSlider();\n  map.addControl(zoomslider);\n  return map;\n}\n\nconst map1 = createMap('map1');\nconst map2 = createMap('map2');\nconst map3 = createMap('map3');\n"],"sourceRoot":""}