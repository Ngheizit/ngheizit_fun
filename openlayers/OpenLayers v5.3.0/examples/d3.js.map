{"version":3,"sources":["webpack:///../src/ol/source/ImageCanvas.js","webpack:///./d3.js"],"names":["source_ImageCanvas","ImageSource","ImageCanvasSource","opt_options","const","options","super","this","attributions","projection","resolutions","state","canvasFunction_","canvasFunction","canvas_","renderedRevision_","ratio_","undefined","ratio","getImageInternal","extent","resolution","pixelRatio","findNearestResolution","let","canvas","getRevision","getResolution","getPixelRatio","Object","ol_extent","getExtent","slice","size","canvasElement","call","ImageCanvas","map","Map","layers","Tile","source","Stamen","layer","target","view","View","center","proj","zoom","d3","json","error","us","features","topojson","feature","objects","counties","Image","canvasWidth","canvasHeight","select","document","createElement","attr","context","node","getContext","d3Projection","geoMercator","scale","translate","d3Path","geoPath","pixelBounds","bounds","pixelBoundsWidth","pixelBoundsHeight","geoBounds","geoBoundsLeftBottom","geoBoundsRightTop","geoBoundsWidth","widthResolution","heightResolution","Math","max","stroke","addLayer"],"mappings":"kKA6HeA,EA5E4B,SAAAC,GAIzC,SAAAC,EAAYC,GAEVC,IAAMC,EAAUF,GAAsC,GAEtDG,OAAKC,KAAC,CACJC,aAAcH,EAAQG,aACtBC,WAAYJ,EAAQI,WACpBC,YAAaL,EAAQK,YACrBC,MAAON,EAAQM,QAOjBJ,KAAKK,gBAAkBP,EAAQQ,eAM/BN,KAAKO,QAAU,KAMfP,KAAKQ,kBAAoB,EAMzBR,KAAKS,YAA2BC,IAAlBZ,EAAQa,MACpBb,EAAQa,MAAQ,oGAOpBC,iBAAA,SAAiBC,EAAQC,EAAYC,EAAYb,GAC/CY,EAAad,KAAKgB,sBAAsBF,GAExCG,IAAIC,EAASlB,KAAKO,QAClB,GAAIW,GACDlB,KAAKQ,mBAAqBR,KAAKmB,eAC/BD,EAAOE,iBAAmBN,GAC1BI,EAAOG,iBAAmBN,GAC1BO,OAAAC,EAAA,EAAAD,CAAeJ,EAAOM,YAAaX,GACpC,OAAOK,EAGTL,EAASA,EAAOY,QAChBH,OAAAC,EAAA,EAAAD,CAAgBT,EAAQb,KAAKS,QAC7BZ,IAEM6B,EAAO,CAFCJ,OAAAC,EAAA,EAAAD,CAAST,GAAUC,EAEXC,EADPO,OAAAC,EAAA,EAAAD,CAAUT,GAAUC,EACQC,GAErCY,EAAgB3B,KAAKK,gBAAgBuB,KACzC5B,KAAMa,EAAQC,EAAYC,EAAYW,EAAMxB,GAO9C,OANIyB,IACFT,EAAS,IAAIW,EAAA,EAAYhB,EAAQC,EAAYC,EAAYY,IAE3D3B,KAAKO,QAAUW,EACflB,KAAKQ,kBAAoBR,KAAKmB,cAEvBD,KAvEgC,OAAX,GCzC1BY,EAAM,IAAIC,EAAA,EAAI,CAClBC,OAAQ,CACN,IAAIC,EAAA,EAAU,CACZC,OAAQ,IAAIC,EAAA,EAAO,CACjBC,MAAO,kBAIbC,OAAQ,MACRC,KAAM,IAAIC,EAAA,EAAK,CACbC,OAAQlB,OAAAmB,EAAA,EAAAnB,CAAW,EAAE,GAAI,KACzBoB,KAAM,MAQVC,GAAGC,KAAK,wBAAyB,SAASC,EAAOC,GAC/CjD,IAAMkD,EAAWC,SAASC,QAAQH,EAAIA,EAAGI,QAAQC,UAmD3Cf,EAAQ,IAAIgB,EAAA,EAAW,CAC3BlB,OAAQ,IAAIzC,EAAkB,CAC5Ba,eA1CmB,SAASO,EAAQC,EAAYC,EAAYW,EAAMxB,GACpEL,IAAMwD,EAAc3B,EAAK,GACnB4B,EAAe5B,EAAK,GAEpBR,EAASyB,GAAGY,OAAOC,SAASC,cAAc,WAChDvC,EAAOwC,KAAK,QAASL,GAAaK,KAAK,SAAUJ,GAEjDzD,IAAM8D,EAAUzC,EAAO0C,OAAOC,WAAW,MAEnCC,EAAenB,GAAGoB,cAAcC,MAAM,GAAGC,UAAU,CAAC,EAAG,IACzDC,EAASvB,GAAGwB,UAAUjE,WAAW4D,GAE/BM,EAAcF,EAAOG,OAAOtB,GAC5BuB,EAAmBF,EAAY,GAAG,GAAKA,EAAY,GAAG,GACtDG,EAAoBH,EAAY,GAAG,GAAKA,EAAY,GAAG,GAEvDI,EAAY7B,GAAG6B,UAAUzB,GACzB0B,EAAsBnD,OAAAmB,EAAA,EAAAnB,CAAWkD,EAAU,GAAItE,GAC/CwE,EAAoBpD,OAAAmB,EAAA,EAAAnB,CAAWkD,EAAU,GAAItE,GAC/CyE,EAAiBD,EAAkB,GAAKD,EAAoB,GAC5DE,EAAiB,IACnBA,GAAkBrD,OAAAC,EAAA,EAAAD,CAASpB,EAAWsB,cAExC3B,IAEM+E,EAAkBD,EAAiBL,EACnCO,GAHkBH,EAAkB,GAAKD,EAAoB,IAGxBF,EAErCP,EADIc,KAAKC,IAAIH,EAAiBC,IACjB/D,EAAaC,GAE1ByB,EAASlB,OAAAmB,EAAA,EAAAnB,CAASA,OAAAC,EAAA,EAAAD,CAAUT,GAASX,GAO3C,OANA4D,EAAaE,MAAMA,GAAOxB,OAAOA,GAC9ByB,UAAU,CAACZ,EAAc,EAAGC,EAAe,KAC9CY,EAASA,EAAOhE,WAAW4D,GAAcH,QAAQA,IAC1CZ,GACPY,EAAQqB,SAED9D,EAAO0C,QAMZ1D,WAAY,gBAGhB4B,EAAImD,SAAS7C","file":"d3.js","sourcesContent":["/**\n * @module ol/source/ImageCanvas\n */\n\nimport ImageCanvas from '../ImageCanvas.js';\nimport {containsExtent, getHeight, getWidth, scaleFromCenter} from '../extent.js';\nimport ImageSource from './Image.js';\n\n\n/**\n * A function returning the canvas element (`{HTMLCanvasElement}`)\n * used by the source as an image. The arguments passed to the function are:\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\n * `{number}` the device pixel ratio, {@link module:ol/size~Size} the image size, and\n * {@link module:ol/proj/Projection} the image projection. The canvas returned by\n * this function is cached by the source. The this keyword inside the function\n * references the {@link module:ol/source/ImageCanvas}.\n *\n * @typedef {function(this:import(\"../ImageCanvas.js\").default, import(\"../extent.js\").Extent, number,\n *     number, import(\"../size.js\").Size, import(\"../proj/Projection.js\").default): HTMLCanvasElement} FunctionType\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {FunctionType} [canvasFunction] Canvas function.\n * The function returning the canvas element used by the source\n * as an image. The arguments passed to the function are: `{import(\"../extent.js\").Extent}` the\n * image extent, `{number}` the image resolution, `{number}` the device pixel\n * ratio, `{import(\"../size.js\").Size}` the image size, and `{import(\"../proj/Projection.js\").Projection}` the image\n * projection. The canvas returned by this function is cached by the source. If\n * the value returned by the function is later changed then\n * `changed` should be called on the source for the source to\n * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}\n * @property {import(\"../proj.js\").ProjectionLike} projection Projection.\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\n * width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, new canvases will be created for these resolutions\n * @property {import(\"./State.js\").default} [state] Source state.\n */\n\n\n/**\n * @classdesc\n * Base class for image sources where a canvas element is the image.\n * @api\n */\nclass ImageCanvasSource extends ImageSource {\n  /**\n   * @param {Options=} opt_options ImageCanvas options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options || /** @type {Options} */ ({});\n\n    super({\n      attributions: options.attributions,\n      projection: options.projection,\n      resolutions: options.resolutions,\n      state: options.state\n    });\n\n    /**\n    * @private\n    * @type {FunctionType}\n    */\n    this.canvasFunction_ = options.canvasFunction;\n\n    /**\n    * @private\n    * @type {import(\"../ImageCanvas.js\").default}\n    */\n    this.canvas_ = null;\n\n    /**\n    * @private\n    * @type {number}\n    */\n    this.renderedRevision_ = 0;\n\n    /**\n    * @private\n    * @type {number}\n    */\n    this.ratio_ = options.ratio !== undefined ?\n      options.ratio : 1.5;\n\n  }\n\n  /**\n  * @inheritDoc\n  */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    resolution = this.findNearestResolution(resolution);\n\n    let canvas = this.canvas_;\n    if (canvas &&\n       this.renderedRevision_ == this.getRevision() &&\n       canvas.getResolution() == resolution &&\n       canvas.getPixelRatio() == pixelRatio &&\n       containsExtent(canvas.getExtent(), extent)) {\n      return canvas;\n    }\n\n    extent = extent.slice();\n    scaleFromCenter(extent, this.ratio_);\n    const width = getWidth(extent) / resolution;\n    const height = getHeight(extent) / resolution;\n    const size = [width * pixelRatio, height * pixelRatio];\n\n    const canvasElement = this.canvasFunction_.call(\n      this, extent, resolution, pixelRatio, size, projection);\n    if (canvasElement) {\n      canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\n    }\n    this.canvas_ = canvas;\n    this.renderedRevision_ = this.getRevision();\n\n    return canvas;\n  }\n}\n\n\nexport default ImageCanvasSource;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {getWidth, getCenter} from '../src/ol/extent.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {fromLonLat, toLonLat} from '../src/ol/proj.js';\nimport {ImageCanvas as ImageCanvasSource, Stamen} from '../src/ol/source.js';\n\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new Stamen({\n        layer: 'watercolor'\n      })\n    })\n  ],\n  target: 'map',\n  view: new View({\n    center: fromLonLat([-97, 38]),\n    zoom: 4\n  })\n});\n\n\n/**\n * Load the topojson data and create an ol/layer/Image for that data.\n */\nd3.json('data/topojson/us.json', function(error, us) {\n  const features = topojson.feature(us, us.objects.counties);\n\n  /**\n   * This function uses d3 to render the topojson features to a canvas.\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/size~Size} size Size.\n   * @param {module:ol/proj/Projection~Projection} projection Projection.\n   * @return {HTMLCanvasElement} A canvas element.\n   */\n  const canvasFunction = function(extent, resolution, pixelRatio, size, projection) {\n    const canvasWidth = size[0];\n    const canvasHeight = size[1];\n\n    const canvas = d3.select(document.createElement('canvas'));\n    canvas.attr('width', canvasWidth).attr('height', canvasHeight);\n\n    const context = canvas.node().getContext('2d');\n\n    const d3Projection = d3.geoMercator().scale(1).translate([0, 0]);\n    let d3Path = d3.geoPath().projection(d3Projection);\n\n    const pixelBounds = d3Path.bounds(features);\n    const pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0];\n    const pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1];\n\n    const geoBounds = d3.geoBounds(features);\n    const geoBoundsLeftBottom = fromLonLat(geoBounds[0], projection);\n    const geoBoundsRightTop = fromLonLat(geoBounds[1], projection);\n    let geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0];\n    if (geoBoundsWidth < 0) {\n      geoBoundsWidth += getWidth(projection.getExtent());\n    }\n    const geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1];\n\n    const widthResolution = geoBoundsWidth / pixelBoundsWidth;\n    const heightResolution = geoBoundsHeight / pixelBoundsHeight;\n    const r = Math.max(widthResolution, heightResolution);\n    const scale = r / (resolution / pixelRatio);\n\n    const center = toLonLat(getCenter(extent), projection);\n    d3Projection.scale(scale).center(center)\n      .translate([canvasWidth / 2, canvasHeight / 2]);\n    d3Path = d3Path.projection(d3Projection).context(context);\n    d3Path(features);\n    context.stroke();\n\n    return canvas.node();\n  };\n\n  const layer = new ImageLayer({\n    source: new ImageCanvasSource({\n      canvasFunction: canvasFunction,\n      projection: 'EPSG:3857'\n    })\n  });\n  map.addLayer(layer);\n});\n"],"sourceRoot":""}